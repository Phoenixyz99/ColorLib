import OpenEXR
import Imath
import numpy as np
import os
import matplotlib.pyplot as plt
import mplcursors

plt.style.use('dark_background')



def read_exr(file_path):
    """Reads an exr file and outputs it in the form of (H, W, (R, G, B)).

    Args:
        file_path (str): Location of the exr to read.

    Raises:
        FileNotFoundError: If the file path is invalid.
        ValueError: If the float/int type for pixel channels is invalid.
        RuntimeError: If the file is not in the expected EXR format or missing channels.
    
    Returns:
        np.ndarray: A numpy array in the format of (H, W, (R, G, B)), 
        or a dict containing all channel data if RGB is not present.
    """

    if not os.path.exists(file_path):
        raise FileNotFoundError(f"File not found! {file_path}")

    try:
        exr_file = OpenEXR.InputFile(file_path)
    except Exception as e:
        raise RuntimeError(f"Failed to read EXR file! {e}")

    try:
        header = exr_file.header() 
        # HACK: For some reason, running .header() on certain images will crash python with no errors. I couldn't figure out why.
        # HACK: Images generated by me don't seem to have this issue, so I guess this doesn't matter.
        data = header['dataWindow']
        width = data.max.x - data.min.x + 1
        height = data.max.y - data.min.y + 1

        channels = header['channels'].keys()
        channel_data = {}

        for channel in channels:
            pixel_type = header['channels'][channel].type

            if pixel_type == Imath.PixelType(Imath.PixelType.HALF):
                dtype = np.float16
            elif pixel_type == Imath.PixelType(Imath.PixelType.FLOAT):
                dtype = np.float32
            elif pixel_type == Imath.PixelType(Imath.PixelType.UINT):
                dtype = np.uint32
            else:
                raise ValueError(f"Unsupported pixel type: {pixel_type}")

            # Format in the shape (H, W)
            channel_data[channel] = np.frombuffer(exr_file.channel(channel, pixel_type), dtype=dtype).reshape((height, width))

            if dtype == np.float16:
                channel_data[channel] = channel_data[channel].astype(np.float32)

        if all(c in channels for c in ['R', 'G', 'B']):
            rgb_image = np.stack([channel_data['R'], channel_data['G'], channel_data['B']], axis=-1)
            rgb_image = np.clip(rgb_image, 0.0, None) # Curse signed numbers...
            return rgb_image
        else:
            # Dump all of the channels if it isn't an RGB image.
            return channel_data
    except Exception as e:
        raise RuntimeError(f"Error processing EXR file! {e}")
    finally:
        exr_file.close()



def save_exr_image(file_path, image_array):
    """
    Saves an EXR image from a NumPy array of shape (W, H, 3), where each element
    corresponds to a pixel's (R, G, B) values.
    
    Args:
        file_path (str): The output path (including name) for the EXR image.
        np.ndarray: An array containing pixel data in the shape (W, H, (R, G, B)).
    """

    if len(image_array.shape) != 3 or image_array.shape[2] != 3:
        raise ValueError("Input image must be a numpy array of shape (W, H, 3)!")

    output_dir = os.path.dirname(file_path)
    if output_dir and not os.path.exists(output_dir):
        os.makedirs(output_dir)

    height, width, _ = image_array.shape

    header = OpenEXR.Header(width, height)

    R = image_array[:, :, 0].astype(np.float32).tobytes()
    G = image_array[:, :, 1].astype(np.float32).tobytes()
    B = image_array[:, :, 2].astype(np.float32).tobytes()

    exr_file = OpenEXR.OutputFile(file_path, header)
    
    exr_file.writePixels({'R': R, 'G': G, 'B': B})

    exr_file.close()




def plot(yaxis, xaxis=None, xlabel="X", ylabel="Y", scale="linear"):
    """Plots the given axis on a matplotlib graph, with a data cursor.
    
    Args:
        yaxis (np.ndarray, required): An array to plot.
        xaixs (np.ndarray): The axis to plot against. This must have the same length as the yaxis. 
         If no xaxis is given, the yaxis will be plotted against its index.
        xlabel (str): The title of the x axis.
        ylabel (str): The title of the y axis.
        scale (str): The scale/type of graph. "linear", "logy", "logx", "logxy", "polar", "logpolar".

    Returns:
        None
        """

    plt.figure(figsize=(10, 5))
    
    if xaxis is None:
        xaxis = list(range(len(yaxis))) # Use the index of yaxis rather than xaxis
    
    if scale == "logy":
        plt.yscale('log')
    elif scale == "logx":
        plt.xscale('log')
    elif scale == "logxy":
        plt.xscale('log')
        plt.yscale('log')
    elif scale == "polar":
        ax = plt.subplot(111, projection='polar')
        ax.plot(xaxis, yaxis, label='Item')
    elif scale == "logpolar":
        ax = plt.subplot(111, projection='polar')
        ax.set_yscale('log')
        ax.plot(xaxis, yaxis, label='Item')
    else:
        plt.plot(xaxis, yaxis, label='Item')

    plt.title(f"{xlabel} vs {ylabel}")
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    plt.grid(True)
    plt.legend()

    # Enable cursor
    cursor = mplcursors.cursor(hover=True)
    cursor.connect("add", lambda sel: sel.annotation.set_text(
        f'X: {xaxis[int(sel.index)]:.16f}\n'
        f'Y: {yaxis[int(sel.index)]:.16f}\n'))

    plt.show()
